<?xml version="1.0" encoding="UTF-8"?><course instant_questions="3" mindmail_reminder_interval="168" description="SOTE1" repeat_questions="2" language="de" name="SOTE1-SS13" check_questions="1" mindmail_interval="48" v="1"><lesson description="" required_correct_answers="75" distance_to_next="11" name="Innere Klassen" body="&lt;p&gt;Es gibt drei Sorten von inneren Klassen. Doch wann verwendet man welche?&lt;/p&gt;" sort="0" max_wrong_answers="0"><question type="MultipleChoice" notice_on_wrong="Synchronized bei Klassen ergibt keinen Sinn. Der Rest stimmt bis auf e)." pattern="" notice="" num_allowed_wrong="0" name="Modifier" body="&lt;p&gt;Welche Modifier sind zugelassen für innere Klassen? &lt;br /&gt;a)    Synchronized&lt;br /&gt;b)    Final&lt;br /&gt;c)    Protected&lt;br /&gt;d)    Static&lt;br /&gt;e)    Keine dieser Möglichkeiten&lt;/p&gt;&#13;&#10;&lt;p&gt;Bitte markieren Sie alle korrekten Antworten.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Antwort d)" correct="true"/><answer notice="" body="Antwort b)" correct="true"/><answer notice="" body="Antwort e)" correct="false"/><answer notice="" body="Antwort c)" correct="true"/><answer notice="" body="Antwort a)" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="In statischen Klassen können Sie statische und nichtstatische Variablen deklarieren." pattern="" notice="" num_allowed_wrong="0" name="Geht das?" body="&lt;p&gt;In welcher Zeile tritt ein Kompilierfehler auf? (Jede richtige Antwort ist zu setzen)&lt;br /&gt;&lt;/p&gt;&#13;&#10;&lt;pre&gt;public class UnsereKlasse {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;    static String a;         // Zeile1&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    final static int b = 1; // Zeile 2&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;    public static class InnereKlasse {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        String c;             // Zeile3&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        static int d;         // Zeile4&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt;Bitte markieren Sie alle korrekten Antworten.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Zeile 1" correct="false"/><answer notice="" body="In keiner Zeile" correct="true"/><answer notice="" body="Zeile 3" correct="false"/><answer notice="" body="Zeile 4" correct="false"/><answer notice="" body="Zeile 2" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="Lokale Klassen innerhalb eines statischen Blocks können nur auf statische Variablen der äußeren Klasse zugreifen." pattern="" notice="" num_allowed_wrong="0" name="Variablenzugriff" body="&lt;p&gt;Auf welche Variablen können Sie innerhalb der lokalen Klasse zugreifen, sprich welche Variablen können Sie dort einsetzen, wo &quot;hier&quot; steht, ohne dass es zu einem Kompilierfehler kommt?&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class LokaleAussen {&lt;br /&gt;    static String a = &quot;eins&quot;;&lt;br /&gt;    static final String b = &quot;zwei&quot;;&lt;br /&gt;    String c = &quot;drei&quot;;&lt;br /&gt;&lt;br /&gt;    static void neu() {&lt;br /&gt;        class LokaleInnen {&lt;br /&gt;            LokaleInnen() {&lt;br /&gt;                System.out.println(&quot;hier&quot;);&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Bitte markieren Sie alle zutreffenden Antworten.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Variable b" correct="true"/><answer notice="" body="Variable c" correct="false"/><answer notice="" body="Variable a" correct="true"/></question><question type="MultipleChoice" notice_on_wrong="andere.machwas implementiert in seiner Parameterliste eine anonyme Klasse und innerhalb dieser Implementierung wurde eine lokale Klasse definiert." pattern="" notice="" num_allowed_wrong="0" name="Typen von inneren Klassen" body="&lt;p&gt;Welcher Typ bzw. Typen von inneren Klassen wurden hier verwendet? Die beiden Klassen AndereKlasse und IInterface brauchen Sie zum Beantworten nicht zu kennen.&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class GanzAussen {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public static void main(String[] args) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        AndereKlasse andere = new AndereKlasse();&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        andere.machWas(new IInterface() {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;            public void machIrgendwas() {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;                class InnereKlasse {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;                    public InnereKlasse() {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;                        System.out.println(&quot;Ich mache irgendwas&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;                    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;                }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;            }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        });&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt;Bitte markieren Sie jede richtige Antwort.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Lokale Klasse" correct="true"/><answer notice="" body="Anonyme innere Klasse" correct="true"/><answer notice="" body="Member Klasse" correct="false"/></question><question type="ClozeText" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Instanzieren innerer Klassen" body="&lt;p&gt;Gegeben sei folgende Klasse:&lt;/p&gt;&#13;&#10;&lt;pre&gt;public class AeussereKlasse {&lt;br /&gt;    class InnereKlasse{&lt;br /&gt;        public InnereKlasse(int a){&lt;br /&gt;            //mach was&lt;br /&gt;        }&lt;br /&gt;    }    &lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt;Die innere Klassen würden sie mit dem Wert 10 instanzieren über (keine unnötigen Leerzeichen, Strichpunkt nicht vergessen):&lt;/p&gt;&#13;&#10;&lt;pre&gt;InnereKlasse innere = [[new AeussereKlasse().new InnereKlasse(10);]]&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""></question></lesson><lesson description="Spezielle Klasse und Themen" required_correct_answers="75" distance_to_next="0" name="Verschiedenes" body="" sort="1" max_wrong_answers="0"><question type="ClozeText" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Log-Levels" body="&lt;p&gt;Tragen Sie in den folgenden Text Zahlen von 1 bis 5 ein und sortieren Sie dabei die Log-Levels von grob nach fein, d.h. so, dass die wenigsten Ausgaben mit 1 und die meisten Ausgaben mit 5 gekennzeichnet sind.&lt;/p&gt;&#13;&#10;&lt;p&gt;info: [[3]]&lt;/p&gt;&#13;&#10;&lt;p&gt;warn: [[2]]&lt;/p&gt;&#13;&#10;&lt;p&gt;finest: [[5]]&lt;/p&gt;&#13;&#10;&lt;p&gt;severe: [[1]]&lt;/p&gt;&#13;&#10;&lt;p&gt;fine: [[4]]&lt;/p&gt;" notice_on_correct=""></question><question type="SingleChoice" notice_on_wrong="" pattern="" notice="In der Tat kann sich das Ergebnis von JVM zu JVM unterscheiden. Üblicherweise ist es &quot;true&quot;." num_allowed_wrong="0" name="Vergleich mit ==" body="&lt;p&gt;Gegeben sei folgender Programmcode:&lt;/p&gt;&#13;&#10;&lt;pre&gt;String eins = &quot;HTWG&quot;;&lt;br /&gt;String zwei = &quot;HTWG&quot;;&lt;br /&gt;System.out.println((eins == zwei));&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Was wird auf der Konsole ausgegeben?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Immer true" correct="false"/><answer notice="" body="Immer false" correct="false"/><answer notice="" body="Das hängt von der Implementierung der JVM ab" correct="true"/></question><question type="SingleChoice" notice_on_wrong="" pattern="" notice="Da java.lang.String die equals-Methode implementiert, d.h. von Object überschrieben hat, und da die Implementierung dieser Methode so ist wie sie ist, wird immer true ausgegeben." num_allowed_wrong="0" name="Vergleich mit equals()" body="&lt;p&gt;Gegeben sei der folgende Programmcode:&lt;/p&gt;&#13;&#10;&lt;pre&gt;String eins = &quot;HTWG&quot;;&lt;br /&gt;String zwei = &quot;HTWG&quot;;&lt;br /&gt;System.out.println(eins.equals(zwei));&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Was wird auf der Konsole ausgegeben?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Immer true" correct="true"/><answer notice="" body="Immer false" correct="false"/><answer notice="" body="Das hängt von der Implementierung der JVM ab" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="Es genügt, die Fahrgestellnummer zu vergleichen, da diese bereits die Objektidentität sicherstellt." num_allowed_wrong="0" name="equals() Methode und Attribute" body="&lt;p&gt;Welches Attribut/welche Attribute sollte man bei einer Klasse &quot;Auto&quot;  &lt;br /&gt;überprüfen (bzw. in der equals()-Methode überprüfen), um sicher zu stellen, dass es das selbe Auto ist?&lt;br /&gt;&lt;br /&gt;Die Klasse besitzt folgende Attribute: Hersteller, Modell, Baujahr, Kennzeichen, Fahrgestellnummer, Leistung in KW, Anzahl Türen, gefahrene Kilometer.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Anzahl Türen" correct="false"/><answer notice="" body="gefahrene Kilometer" correct="false"/><answer notice="" body="Hersteller" correct="false"/><answer notice="" body="Modell" correct="false"/><answer notice="" body="Baujahr" correct="false"/><answer notice="" body="Kennzeichen" correct="false"/><answer notice="" body="Fahrgestellnummer" correct="true"/><answer notice="" body="Leistung in kW" correct="false"/></question><question type="ClozeText" notice_on_wrong="" pattern="" notice="Da Auto die equals()-Methode von Object überschreiben soll, muss der Übergabeparameter auch Object sein." num_allowed_wrong="0" name="Eigene equals Methode" body="&lt;p&gt;Bitte ergänzen Sie den folgenden Code, so dass sich eine korrekte Signatur der equals()-Methode einer Klasse htwg.Auto ergibt:&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public [[boolean]] equals([[Object]] anderesAuto) {...}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""></question><question type="ClozeText" notice_on_wrong="" pattern="" notice="Beim Implementieren sollten Sie in der Tat diese Prüfungen zuerst vornehmen, bevor Sie Ihre eigentliche Logik schreiben, d.h. die Prüfung der Attribute." num_allowed_wrong="0" name="Eigene equals Methode (2)" body="&lt;p&gt;Wenn Sie eine eigene equals-Methode für eine Klasse &quot;htwg.Auto&quot;, die direkt von Object erbt, implementieren, sollten Sie auf Folgendes achten:&lt;/p&gt;&#13;&#10;&lt;ol&gt;&#13;&#10;&lt;li&gt;Wenn der Methode this übergeben wird muss [[true]] zurückgeben werden&lt;/li&gt;&#13;&#10;&lt;li&gt;Wenn der Methode null übergeben wird muss [[false]] zurückgeben werden&lt;/li&gt;&#13;&#10;&lt;li&gt;Wenn der Methode eine andere Klasse als Auto übergeben wird muss [[false]] zurückgeben werden.&lt;/li&gt;&#13;&#10;&lt;/ol&gt;" notice_on_correct=""></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="Das int-Array war gemein, oder? Arrays werden in der Tat als Referenz übergeben." num_allowed_wrong="0" name="Übergabe per Referenz" body="&lt;p&gt;Welche der folgenden Variablen werden per Referenz übergeben? Bitte anklicken.&lt;/p&gt;" notice_on_correct=""><answer notice="" body="int a = 5;" correct="false"/><answer notice="" body="String b = new String(&quot;Hallo&quot;);" correct="true"/><answer notice="" body="int[] c = new int[2];" correct="true"/><answer notice="" body="Object d = new Object();" correct="true"/><answer notice="" body="double e = 5.5;" correct="false"/></question><question type="ClozeText" notice_on_wrong="" pattern="" notice="War gar nicht so einfach, oder? Unterscheiden Sie immer interne und externe Enumerations." num_allowed_wrong="0" name="Enums" body="&lt;p&gt;Gegeben sei der folgende Code, den Sie ergänzen müssen:&lt;/p&gt;&#13;&#10;&lt;pre&gt;public enum Land {&lt;br /&gt;    D, CH, A&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Student {&lt;br /&gt;    [[public]] [[enum]] Studiengang{WI, TI, SE}; //hier wird eine Enumeration Studiengang angelegt&lt;br /&gt;    private Land land;&lt;br /&gt;    private [[Studiengang]] studiengang;&lt;br /&gt;&lt;br /&gt;    public Student([[Land]] land, Studiengang studiengang) {&lt;br /&gt;        this.land = land;&lt;br /&gt;        this.studiengang = studiengang;&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class StartStudent {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public static void main(String[] args) {&lt;br /&gt;        //Deutschen WI-Studenten anlegen!!&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        Student student = new Student([[Land.D]], [[Student.Studiengang.WI]]);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;}&lt;/pre&gt;" notice_on_correct=""></question></lesson><lesson description="Vererbung, Interfaces und mehr" required_correct_answers="75" distance_to_next="1" name="Vererbung und Casting" body="&lt;p&gt;Interfaces und abstrakte Klassen haben viele Gemeinsamkeiten und Unterschiede. Hier lernen Sie diese kennen.&lt;/p&gt;" sort="2" max_wrong_answers="0"><question type="SingleChoice" notice_on_wrong="Man kann nicht einfach Downcasten" pattern="" notice="" num_allowed_wrong="0" name="Vererbung" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;package abstracts;&lt;br /&gt;&lt;br /&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;package abstracts;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;public class Auto extends Fahrzeug {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public static void main(String[] args) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        Fahrzeug fahrzeug = (Auto) new Fahrzeug();&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        fahrzeug.starten();&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    &lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public void fahren(){&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;" notice_on_correct=""><answer notice="" body="Ausgabe auf der Konsole &quot;Das Auto fährt&quot;" correct="false"/><answer notice="" body="Beim Ausführen tritt eine ClassCastException auf" correct="true"/><answer notice="" body="Der Code kompiliert nicht" correct="false"/><answer notice="" body="Ausgabe auf der Konsole &quot;Das Fahrzeug fährt&quot;" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Achtung Falle: Auto erbt nicht von Fahrzeug" pattern="" notice="" num_allowed_wrong="0" name="Casting" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;package abstracts;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;public class Auto {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public static void main(String[] args) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        Fahrzeug fahrzeug = (Auto) new Fahrzeug();&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        fahrzeug.starten();&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    &lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public void fahren(){&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;" notice_on_correct=""><answer notice="" body="Das Programm bricht mit einer ClassCastException ab" correct="false"/><answer notice="" body="Auf der Konsole wird &quot;Das Fahrzeug fährt&quot; ausgegeben" correct="false"/><answer notice="" body="Code kompiliert nicht" correct="true"/><answer notice="" body="Auf der Konsole wird &quot;Das Auto fährt&quot; ausgegeben" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Die Methoden der Superklasse werden überschrieben. Entsprechend stammt die Ausgabe von der Subklasse." pattern="" notice="" num_allowed_wrong="0" name="Vererbung 2" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public abstract class Fahrzeug {&lt;br /&gt;    public abstract void fahren();&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto extends Fahrzeug {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Fahrzeug fahrzeug = new Auto();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Ausgabe auf der Konsole &quot;Das Auto fährt&quot;" correct="true"/><answer notice="" body="Programm bricht mit ClassCastException ab" correct="false"/><answer notice="" body="Ausgabe auf der Konsole &quot;Das Fahrzeug fährt&quot;" correct="false"/><answer notice="" body="Code kompiliert nicht" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Zugegeben, das ist eine schwierige Sache. Die JVM merkt sich, dass es sich bei dem Auto eigentlich um ein Auto handelt (trotz des Upcasts). Folglich wird die Methode der Subklasse ausgegeben." pattern="" notice="" num_allowed_wrong="0" name="Upcasting" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto extends Fahrzeug {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Fahrzeug fahrzeug = new Auto();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Programm bricht mit ClassCastException ab" correct="false"/><answer notice="" body="Code kompiliert nicht" correct="false"/><answer notice="" body="Auf Konsole wird ausgegeben &quot;Das Fahrzeug fährt&quot;" correct="false"/><answer notice="" body="Auf Konsole wird ausgegeben &quot;Das Auto fährt&quot;" correct="true"/></question><question type="SingleChoice" notice_on_wrong="Hier ist wirklich nur das Fahrzeug beteiligt. Vom Auto wird folglich nichts aufgerufen." pattern="" notice="" num_allowed_wrong="0" name="Casting 2" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto extends Fahrzeug {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Fahrzeug fahrzeug = new Fahrzeug();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Programm bricht mit ClassCastException ab" correct="false"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Fahrzeug fährt&quot;" correct="true"/><answer notice="" body="Code kompiliert nicht" correct="false"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Auto fährt&quot;" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Es gibt einen Kompilierfehler. Man müsste explizit &quot;Downcasten&quot;" pattern="" notice="" num_allowed_wrong="0" name="Casting 3" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto extends Fahrzeug {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Auto fahrzeug = new Fahrzeug();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Auto fährt&quot;" correct="false"/><answer notice="" body="Das Programm bricht mit einer ClassCastException ab" correct="false"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Fahrzeug fährt&quot;" correct="false"/><answer notice="" body="Der Code kompiliert nicht" correct="true"/></question><question type="SingleChoice" notice_on_wrong="Hier gibt es eine ClassCastException, weil man nicht einfach von einer Super- auf eine Subklasse downcasten kann (wenn diese nicht ursprünglich eine Instanz der Subklasse war)." pattern="" notice="" num_allowed_wrong="0" name="Casting 4" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public class Fahrzeug {&lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Fahrzeug fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto extends Fahrzeug {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Auto fahrzeug = (Auto)new Fahrzeug();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Der Code kompiliert nicht" correct="false"/><answer notice="" body="Das Programm bricht mit einer ClassCastException ab" correct="true"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Fahrzeug fährt&quot;" correct="false"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Auto fährt&quot;" correct="false"/></question></lesson><lesson description="try-catch-finally und die ganze Hierarchie" required_correct_answers="70" distance_to_next="1" name="Fehlerbehandlung" body="&lt;p&gt;Für das Thema Fehlerbehandlung in Java sollten Sie wissen und kennen:&lt;/p&gt;&#13;&#10;&lt;ul&gt;&#13;&#10;&lt;li&gt;die Hierarchie der &quot;Fehlerklassen&quot;&lt;/li&gt;&#13;&#10;&lt;li&gt;Die Besonderheiten von Runnable&lt;/li&gt;&#13;&#10;&lt;li&gt;Fehlerbehandlung mit try-catch-finally &lt;/li&gt;&#13;&#10;&lt;li&gt;Fehlerbehandlung durch &quot;Weiterwerfen&quot;&lt;/li&gt;&#13;&#10;&lt;li&gt;Die Merkregeln zu Fehlerbehandlung&lt;/li&gt;&#13;&#10;&lt;li&gt;Werfen von Fehlern und schreiben eigener Fehlerklassen&lt;/li&gt;&#13;&#10;&lt;/ul&gt;" sort="3" max_wrong_answers="1"><question type="SingleChoice" notice_on_wrong="Es tritt in der Tat eine ArithmetikException auf, die nicht gefangen wird (kein catch-Block). Finally wird immer ausgeführt." pattern="" notice="" num_allowed_wrong="0" name="Fehlerkaskade 1" body="&lt;p&gt;Was passiert, wenn Sie folgenden Code kompilieren/ausführen:&lt;/p&gt;&#13;&#10;&lt;pre&gt;public static void main(String[] args) throws ArithmeticException {&lt;br /&gt;          try {&lt;br /&gt;                System.out.println((5/0));&lt;br /&gt;          } finally {&lt;br /&gt;                System.out.println(&quot;Finally&quot;);&lt;br /&gt;          }&lt;br /&gt;          System.out.println(&quot;Ende&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="ArithmeticException wird geworfen, „Finally“, „Ende“" correct="false"/><answer notice="" body="ArithmeticException wird geworfen, „Ende“" correct="false"/><answer notice="" body="„Ende“" correct="false"/><answer notice="" body="„Finally“, „Ende“" correct="false"/><answer notice="" body="ArithmeticException wird geworfen, „Finally“" correct="true"/><answer notice="" body="„Finally“" correct="false"/><answer notice="" body="ArithmeticException wird geworfen, sonst keine weitere Ausgabe" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Ein Fehler kann nicht zweimal geworfen werden. Der Code kompiliert nicht einmal" pattern="" notice="" num_allowed_wrong="0" name="Fehlerkaskade 2" body="&lt;p&gt;Was passiert wenn man folgenden Code schreibt/kompiliert/ausführt?&lt;/p&gt;&#13;&#10;&lt;pre&gt;public static void main(String[] args) throws FileNotFoundException {&lt;br /&gt;        try {&lt;br /&gt;            throw new FileNotFoundException();&lt;br /&gt;        } catch (ArithmeticException dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;fangen&quot;);&lt;br /&gt;        } catch (ArithmeticException dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;nochmals fangen&quot;);&lt;br /&gt;        } finally {&lt;br /&gt;            System.out.println(&quot;Restarbeit&quot;);&lt;br /&gt;        }&lt;br /&gt;        System.out.println(&quot;Endet&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Ausgabe: fangen, nochmals fangen, Restarbeit, Endet&#13;&#10;Programm bricht mit Fehler ab" correct="false"/><answer notice="" body="Nichts" correct="false"/><answer notice="" body="Ausgabe: fangen, Endet&#13;&#10;Programm bricht mit Fehler ab" correct="false"/><answer notice="" body="Ausgabe: Restarbeit&#13;&#10;Programm bricht mit Fehler ab" correct="false"/><answer notice="" body="Kompiliert nicht" correct="true"/><answer notice="" body="Ausgabe: fangen, Restarbeit, Endet&#13;&#10;Programm bricht mit Fehler ab" correct="false"/><answer notice="" body="Ausgabe: fangen, Endet" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Der spezifischste Fehler, der hier gefangen wird, ist hier Exception. Damit ist der Fehler behandelt. Folglich wird ausgegeben &quot;nochmals fangen, Restarbeit, endet" pattern="" notice="" num_allowed_wrong="0" name="Fehlerkaskade 3" body="&lt;p&gt;Was passiert, wenn man folgendes Programm schreibt/kompiliert/ausführt?&lt;/p&gt;&#13;&#10;&lt;pre&gt;public static void main(String[] args) throws FileNotFoundException {&lt;br /&gt;        try {&lt;br /&gt;            throw new FileNotFoundException();&lt;br /&gt;        } catch (ArithmeticException dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;fangen&quot;);&lt;br /&gt;        } catch (Exception dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;nochmals fangen&quot;);&lt;br /&gt;        } finally {&lt;br /&gt;            System.out.println(&quot;Restarbeit&quot;);&lt;br /&gt;        }&lt;br /&gt;        System.out.println(&quot;Endet&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Ausgabe: nochmals fangen, Restarbeit, endet" correct="true"/><answer notice="" body="Programm endet mit Fehler" correct="false"/><answer notice="" body="Kompiliert nicht" correct="false"/><answer notice="" body="Ausgabe: fangen, nochmals fangen, Restarbeit, endet&#13;&#10;Programm endet mit Fehler" correct="false"/><answer notice="" body="Ausgabe: nochmals fangen, Restarbeit, endet&#13;&#10;Programm endet mit Fehler" correct="false"/></question><question type="SingleChoice" notice_on_wrong="IOException ist eine Superklasse von FileNotFoundException. Daher wird der Fehler gefangen und behandelt." pattern="" notice="" num_allowed_wrong="0" name="Fehlerkaskade 4" body="&lt;p&gt;Was passiert, wenn man folgendes Programm schreibt/kompiliert/ausführt?&lt;/p&gt;&#13;&#10;&lt;pre&gt;public static void main(String[] args) throws FileNotFoundException {&lt;br /&gt;        try {&lt;br /&gt;            throw new FileNotFoundException();&lt;br /&gt;        } catch (ArithmeticException dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;fangen&quot;);&lt;br /&gt;        } catch (IOException dokumentFehler) {&lt;br /&gt;            System.out.println(&quot;nochmals fangen&quot;);&lt;br /&gt;        } finally {&lt;br /&gt;            System.out.println(&quot;Restarbeit&quot;);&lt;br /&gt;        }&lt;br /&gt;        System.out.println(&quot;Endet&quot;);&lt;br /&gt;    }&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Ausgabe: nochmals fangen, Restarbeit, endet" correct="true"/><answer notice="" body="Ausgabe: nochmals fangen, Restarbeit, endet&#13;&#10;Programm bricht mit Fehler ab" correct="false"/><answer notice="" body="Nichts" correct="false"/><answer notice="" body="Ausgabe: fangen, nochmals fangen, Restarbeit, endet" correct="false"/><answer notice="" body="Ausgabe: fangen, nochmals fangen, Restarbeit, endet&#13;&#10;Programm bricht mit Fehler ab" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="Asserts führen zu AssertionErrors, also Errors." pattern="" notice="" num_allowed_wrong="0" name="Error" body="&lt;p&gt;Wann wird ein Error geworfen?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Bei nicht erfülltem Assert-Statements" correct="true"/><answer notice="" body="Wenn der Code nicht kompiliert" correct="false"/><answer notice="" body="Wenn ein File nicht gefunden wird (das z.B. eingelesen werden soll)" correct="false"/><answer notice="" body="Bei Fehlern in der JVM" correct="true"/><answer notice="" body="Wenn eine Klasse nicht gefunden wird, die über Reflection instanziert werden soll" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Exception" body="&lt;p&gt;Exceptions werden geworfen&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Wenn der Code nicht kompiliert werden kann" correct="false"/><answer notice="" body="Wenn das Programm zu viel Speicher braucht, um ausgeführt zu werden" correct="false"/><answer notice="" body="Wenn eine Klasse nicht gefunden wird, die über Reflection instanziert werden soll" correct="true"/><answer notice="" body="Wenn ein int-Wert durch 0 geteilt werden soll" correct="true"/></question><question type="MultipleChoice" notice_on_wrong="Sie müssen nur Exceptions behandeln, die nicht von RunTimeException erben. Errors behandelt man üblicherweise nicht. Einen AssertionError zu behandeln ist widersinnig. Schließlich möchte man damit das Programm zu sofortigen beenden zwingen.&#13;&#10;Achtung: Fälschlicherweise verlangte der Mindmailer, dass man ClassNotFoundException hier anklickt. Das stimmt natürlich nicht." pattern="" notice="" num_allowed_wrong="0" name="RuntimeException" body="&lt;p&gt;Welche der folgenden Fehler brauchen Sie nicht zu behandeln?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="ClassNotFoundException" correct="false"/><answer notice="" body="IOException" correct="false"/><answer notice="" body="ArithmeticException" correct="true"/><answer notice="" body="AssertionError" correct="true"/><answer notice="" body="IllegalArgumentException" correct="true"/></question></lesson><lesson description="" required_correct_answers="70" distance_to_next="-1" name="Abstrakte Klassen und Interfaces" body="" sort="4" max_wrong_answers="3"><question type="SingleChoice" notice_on_wrong="Abstrakte Klassen können nicht instanziert werden. Das merkt schon der Compiler." pattern="" notice="" num_allowed_wrong="0" name="Abstrakte Klassen" body="&lt;p&gt;Welches Ergebnis liefert der nachfolgende Quellcode?&lt;/p&gt;&#13;&#10;&lt;pre&gt;public abstract class Fahrzeug {&lt;br /&gt;    public abstract void fahren();&lt;br /&gt;&lt;br /&gt;    public void starten() {&lt;br /&gt;        fahren();&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public class Auto  {&lt;br /&gt;    public static void main(String[] args) {&lt;br /&gt;        Fahrzeug fahrzeug = (Auto) new Fahrzeug();&lt;br /&gt;        fahrzeug.starten();&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    public void fahren(){&lt;br /&gt;        System.out.println(&quot;Das Auto fährt&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Auto fährt&quot; " correct="false"/><answer notice="" body="Code kompiliert nicht" correct="true"/><answer notice="" body="Programm bricht mit ClassCastException ab" correct="false"/><answer notice="" body="Auf der Konsole wird ausgegeben &quot;Das Fahrzeug fährt&quot; " correct="false"/></question><question type="SingleChoice" notice_on_wrong="Vererbung (von einer abstrakten Klasse) scheidet aus, weil man nur einmal erben kann." pattern="" notice="" num_allowed_wrong="0" name="Abstrakt oder Vererbung?" body="&lt;p&gt;Über eine Netzwerkschnittstelle werden Objekte verschiedener Klassen gesendet. Alle diese zu übertragenden Klassen/Objekte sollen die Methode execute() zur Verfügung stellen. Eine dieser Klassen erbt von der abstrakten Klasse Benutzer.&lt;br /&gt;&lt;br /&gt;Sollte der Programmierer in diesem Fall ein Interface oder besser eine abstrakte Klasse verwenden, um die execute() Methode zur Verfügung zu stellen?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Abstrakte Klasse" correct="false"/><answer notice="" body="Interface" correct="true"/></question><question type="ClozeText" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Abstrakt versus Vererbung" body="&lt;p&gt;Ergänzen Sie den folgenden Lückentext beispielsweise mit Wörtern wie Vererbung, Interfaces, extends, instanziert.&lt;/p&gt;&#13;&#10;&lt;p&gt;Wenn Sie von einer Klasse erben wollen, nutzen Sie das Schlüsselwort [[extends]].Während eine Klasse mehrere [[~.nterfa.*|Interfaces]] implementieren kann, ist es in Java nur möglich, von einer Klasse zu erben.&lt;/p&gt;&#13;&#10;&lt;p&gt;Wenn Sie Code bereits implementieren wollen, welchen andere Klassen nutzen können sollen empfiehlt sich die [[~.ererb.*|Vererbung]].&lt;/p&gt;&#13;&#10;&lt;p&gt;Wenn man von abstrakten Klassen erbt, sollte man darauf achten, dass diese erbende Klasse im Gegensatz zu Interfaces [[~.nstanz.*|instanziert]] werden kann.&lt;/p&gt;" notice_on_correct=""></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Abstrakte, Vererbung, Interfaces" body="&lt;p&gt;Bitte markieren Sie die korrekten Aussagen:&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Abstrakte Klassen haben nur abstrakte Methoden." correct="false"/><answer notice="" body="Von abstrakten Klassen kann man erben." correct="true"/><answer notice="" body="Auf abstrakten Klassen kann man Methoden implementieren." correct="true"/><answer notice="" body="Wenn eine Klasse über eine abstrakte Methode verfügt, so muss sie selbst abstrakt sein." correct="true"/><answer notice="" body="Interfaces kann man im Gegensatz zu abstrakten Klassen nicht instanzieren." correct="false"/></question></lesson><lesson description="" required_correct_answers="70" distance_to_next="1" name="Reflection" body="&lt;p&gt;Reflections sind ein sehr hilfreiches aber auch gefährliches Werkzeug. Sie erlauben es, erst zur Laufzeit, über die zu instanzierenden Klasse und aufzurufenden Methoden zu entscheiden.&lt;/p&gt;" sort="5" max_wrong_answers="3"><question type="SingleChoice" notice_on_wrong="" pattern="" notice="" num_allowed_wrong="0" name="Basics" body="&lt;p&gt;Reflection wird eingesetzt, um&lt;/p&gt;" notice_on_correct=""><answer notice="" body="eine Alternative zur Vererbung zu haben" correct="false"/><answer notice="" body="erst während der Laufzeit über die Auswahl von zu instanzierenden Klassen und aufzurufenden Methoden zu entscheiden" correct="true"/><answer notice="" body="Klassen mit Metainformationen zu ergänzen" correct="false"/><answer notice="" body="keine der genannten Möglichkeiten" correct="false"/></question><question type="ClozeText" notice_on_wrong="Puh, das war schwer? Schauen Sie sich die Lösung an und probieren Sie es das nächste Mal wieder." pattern="" notice="" num_allowed_wrong="0" name="Instanzieren" body="&lt;p&gt;Gegeben sei die folgende Klasse:&lt;/p&gt;&#13;&#10;&lt;pre&gt;    package annotations;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    public class Name {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        private String vorname;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        private String nachname;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        public Name(String vorname, String nachname) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;            this.vorname = vorname;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;            this.nachname = nachname;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        }&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        public String getNachname() {return nachname;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        public void setNachname(String nachname) {this.nachname = nachname;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        public String getVorname() {return vorname;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        public void setVorname(String vorname) {this.vorname = vorname;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    }&lt;/pre&gt;&#13;&#10;&lt;p&gt;Bitte ergänzen Sie den Code, mit dem diese Klasse mit den Werten &quot;Anton&quot; und &quot;Schmid&quot; instanziert werden kann. Bitte nutzen Sie &lt;strong&gt;keine &lt;/strong&gt;Leerzeichen.&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;Class klasse = Class.forName(&quot;[[annotations.Name]]&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;Class[] parameterTypes = {[[String.class,String.class]]};&lt;/pre&gt;&#13;&#10;&lt;pre&gt;Constructor konstruktor = klasse.getConstructor([[parameterTypes]]);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;Object[] argumente = [[{&quot;Anton&quot;,&quot;Schmid&quot;}]];&lt;/pre&gt;&#13;&#10;&lt;pre&gt;Name name = (Name)konstruktor.newInstance([[argumente]]);&lt;/pre&gt;" notice_on_correct=""></question><question type="SingleChoice" notice_on_wrong="Mit getMethods bekommen Sie alle public und alle geerbten Methoden (hier von Object) angezeigt. Mit getDeclaredMethods bekommen Sie nur alle (public und private) Methoden angezeigt, die direkt auf der Klasse deklariert sind." pattern="" notice="" num_allowed_wrong="0" name="DeclaredMethods" body="&lt;p&gt;Gegeben sei die folgende Klasse:&lt;/p&gt;&#13;&#10;&lt;pre&gt;    package annotations;&lt;br /&gt;    public class Name {&lt;br /&gt;        private String vorname;&lt;br /&gt;        private String nachname;&lt;br /&gt;        public Name(String vorname, String nachname) {&lt;br /&gt;            this.vorname = vorname;&lt;br /&gt;            this.nachname = nachname;&lt;br /&gt;        }&lt;br /&gt;        public String getNachname() {return nachname;}&lt;br /&gt;        public void setNachname(String nachname) {this.nachname = nachname;}&lt;br /&gt;        public String getVorname() {return vorname;}&lt;br /&gt;        private void setVorname(String vorname) {this.vorname = vorname;}&lt;br /&gt;    }&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Wie groß ist folgendes Array?&lt;/p&gt;&#13;&#10;&lt;p&gt;Method[] methoden = Name.class.getMethods() ;&lt;/p&gt;" notice_on_correct=""><answer notice="" body="vier" correct="false"/><answer notice="" body="keine" correct="false"/><answer notice="" body="drei" correct="false"/><answer notice="" body="mehr als vier" correct="true"/><answer notice="" body="eins oder zwei" correct="false"/></question></lesson><lesson description="" required_correct_answers="70" distance_to_next="1" name="Annotations" body="&lt;p&gt;Annotationen sind ein neues Sprachmerkmal seit Java 5. Mit ihrer Hilfe kann man Metadaten beispielsweise zu Klassen und Methoden hinzufügen.&lt;/p&gt;" sort="6" max_wrong_answers="3"><question type="SingleChoice" notice_on_wrong="Ist klar, oder?" pattern="" notice="" num_allowed_wrong="0" name="Basics" body="&lt;p&gt;Was sind Annotations&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Metadaten" correct="true"/><answer notice="" body="Teile der JavaDoc" correct="false"/><answer notice="" body="Keine der anderen genannten Möglichkeiten" correct="false"/><answer notice="" body="Anderer Begriff für Attribute" correct="false"/></question><question type="SingleChoice" notice_on_wrong="Auch das sollten Sie wissen. Schauen Sie einfach nochmals ins Skript." pattern="" notice="" num_allowed_wrong="0" name="Definition von Annotations" body="&lt;p&gt;Wie definiert man Annotations?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="@interface &lt;NAME_DER_ANNOTATION&gt; {...}" correct="true"/><answer notice="" body="interface &lt;NAME_DER_ANNOTATION&gt; {...}" correct="false"/><answer notice="" body="keine der übrigen Antworten" correct="false"/><answer notice="" body="extends &lt;NAME_DER_ANNOTATION&gt; {...}" correct="false"/></question><question type="MatchTask" notice_on_wrong="" pattern="" notice="Unter java.lang.annotation.ElementType sind die Typen definiert. Sie annotieren Ihre Annotation selbst, beispielsweise so:&#13;&#10;&#13;&#10;@Target( value = { TYPE, METHOD, CONSTRUCTOR, PACKAGE} )&#13;&#10;public @interface VendorInformation {...}" num_allowed_wrong="0" name="Targets" body="&lt;p&gt;Was kann man annotieren? Bitte ordnen Sie die Schlüsselworte zu.&lt;/p&gt;" notice_on_correct=""><answer notice="CONSTRUCTOR" body="Konstruktoren" correct="true"/><answer notice="FIELD" body="Attribute" correct="true"/><answer notice="METHOD" body="Methoden" correct="true"/><answer notice="TYPE" body="Klassen" correct="true"/></question><question type="MultipleChoice" notice_on_wrong="Doch, es gehen wirklich alle..." pattern="" notice="" num_allowed_wrong="0" name="Targets 2" body="&lt;p&gt;Was kann man alles annotieren?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Methoden" correct="true"/><answer notice="" body="Lokale Variablen" correct="true"/><answer notice="" body="Klassen" correct="true"/><answer notice="" body="Konstruktoren" correct="true"/><answer notice="" body="Attribute (Klassenvariablen)" correct="true"/><answer notice="" body="Übergabeparameter" correct="true"/><answer notice="" body="Packages" correct="true"/></question><question type="MatchTask" notice_on_wrong="Waren Sie unkonzentriert?" pattern="" notice="" num_allowed_wrong="0" name="Retention Policy" body="&lt;p&gt;Welche RetentionPolicy wählen Sie, wenn Sie die Annotation auslesen können&lt;/p&gt;" notice_on_correct=""><answer notice="CLASS" body="im kompilierten Code" correct="true"/><answer notice="SOURCE" body="im Quellcode" correct="true"/><answer notice="RUNTIME" body="während der Laufzeit" correct="true"/></question><question type="ClozeText" notice_on_wrong="War nicht einfach, ich weiß. Achten Sie v.a. auf die geschweiften Klammern bei dem Array und den runden Klammer um die ganzen Parameter. Auch die Enum war schwierig, oder?" pattern="" notice="" num_allowed_wrong="0" name="Verwendung von Annotations" body="&lt;p&gt;Gegeben sei folgende Annotation:&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;public @interface VendorInformation {&lt;br /&gt;    enum Country {Germany, Austria, Swiss};&lt;br /&gt;    String companyName(); &lt;br /&gt;    String[] addressData();&lt;br /&gt;    Country country();&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt;Sie möchten nun eine Klasse mit folgenden Werten annotieren:&lt;/p&gt;&#13;&#10;&lt;ul&gt;&#13;&#10;&lt;li&gt;Firmenname sei &quot;HTWG&quot;&lt;/li&gt;&#13;&#10;&lt;li&gt;Die Adresse besteht aus den Zeilen &quot;Konstanz&quot; und &quot;78462&quot;.&lt;/li&gt;&#13;&#10;&lt;li&gt;Das Land ist Deutschland.&lt;/li&gt;&#13;&#10;&lt;/ul&gt;&#13;&#10;&lt;p&gt;Bitte ergänzen Sie die Annotation entsprechend. Bitte verwenden Sie &lt;strong&gt;keine&lt;/strong&gt; Leerzeichen, Zeilenumbrüche oder ähnliches und verwenden Sie die Werte in der angegebenen Reihenfolge.&lt;/p&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;@VendorInformation([[companyName=&quot;HTWG&quot;,addressData={&quot;Konstanz&quot;,&quot;78462&quot;},country=VendorInformation.Country.Germany]])&lt;br /&gt;public class ClassWithAnnotation {..}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;" notice_on_correct=""></question></lesson><lesson description="" required_correct_answers="70" distance_to_next="1" name="Multithreading" body="&lt;p&gt;In dieser Lektion besprechen wir, wie Threads gestartet, beendet, synchronisiert und zusammengeführt werden.&lt;/p&gt;" sort="7" max_wrong_answers="3"><question type="MultipleChoice" notice_on_wrong="Threads werden mit start gestartet, dabei wird dann die Methode run() ausgeführt." pattern="" notice="" num_allowed_wrong="0" name="Einführung ins Multithreading" body="&lt;p&gt;Welche der folgenden Aussagen sind zutreffend?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Ein Thread kann zweimal mit der Methode start() gestartet werden" correct="false"/><answer notice="" body="Ein neuer Thread kann mit der Methode run() gestartet werden" correct="false"/><answer notice="" body="Die Methode join() von java.lang.Thread ist static" correct="false"/><answer notice="" body="Die Klasse Thread implements Runnable" correct="true"/><answer notice="" body="Die Methode wait() gehört zu der Klasse Object" correct="true"/></question><question type="SingleChoice" notice_on_wrong="Es muss heißen &quot;extends&quot;, nicht &quot;implements&quot;" pattern="" notice="" num_allowed_wrong="0" name="Kompilieren" body="&lt;p&gt;In welcher Zeile tritt erstmals ein Kompilierfehler auf?&lt;/p&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;pre&gt;public class Faden implements Thread {         // Zeile 1&lt;br /&gt;    public static void main(String[] args) {// Zeile 2&lt;br /&gt;        Faden faden = new Faden();             // Zeile 3&lt;br /&gt;        faden.start();                         // Zeile 4&lt;br /&gt;    } &lt;br /&gt;&lt;br /&gt;    public void run() { &lt;br /&gt;    System.out.println(&quot;Dies ist ein Faden!&quot;); //Zeile 5&lt;br /&gt;    } &lt;br /&gt;} &lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Zeile 3" correct="false"/><answer notice="" body="Zeile 4" correct="false"/><answer notice="" body="Zeile 1" correct="true"/><answer notice="" body="Zeile 5" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="Die Methode interrupt() muss erst implementiert sein." pattern="" notice="" num_allowed_wrong="0" name="Beenden von Threads" body="&lt;p&gt;Wann wird ein Thread zuverlässig beendet?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Immer, wenn eine Exception auftritt, der nicht behandelt wird" correct="true"/><answer notice="" body="Immer, wenn er zu ende gelaufen ist" correct="true"/><answer notice="" body="Immer, wenn jemand die Methode interrupt() aufruft" correct="false"/></question></lesson><lesson description="RegExp bis zum Abwinken" required_correct_answers="70" distance_to_next="1" name="Reguläre Ausdrücke" body="" sort="8" max_wrong_answers="3"><question type="OpenQuestion" notice_on_wrong="Okay, diese Aufgabe ist wirklich schwer! Hier die Lösung:&#13;&#10;32-78462-" pattern="32-78462-" notice="" num_allowed_wrong="0" name=" Matcher" body="&lt;p&gt;Geben sei der folgende Source-Code&lt;/p&gt;&#13;&#10;&lt;pre&gt;        String input = &quot;Max Mustermann, Rheingustrasse 32, 78462 Konstanz&quot;;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        Pattern p = Pattern.compile(&quot;[0-9]+&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        Matcher m = p.matcher(input);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        while (m.find()) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;            System.out.print(input.substring(m.start(), m.end()) + &quot;-&quot;);&lt;/pre&gt;&#13;&#10;&lt;pre&gt;        }&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt;Was wird auf der Console ausgegeben?&lt;/p&gt;" notice_on_correct="Respekt"></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="Zur Erinnerung: Mit runden Klammern bilden Sie Ausdrücke, für die Sie mit ?, + und * festlegen könne, wie oft Sie auftreten. s ist ein Wortzeichen. Den Punkt (.) müssen Sie escapen, sonst bedeutet er &quot;irgend ein Zeichen&quot;." num_allowed_wrong="0" name=" Wer matched?" body="&lt;p&gt;Welche Strings werden durch dies Pattern gematched und geben true zurück?&lt;/p&gt;&#13;&#10;&lt;pre&gt;Pattern p = Pattern.compile(&quot;(([a-zA-Z]+)\\s)*+([0-9]+)*\\s(([a-zA-Z]+)\\.)&quot;);&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;" notice_on_correct=""><answer notice="" body="String text1 = &quot;An der FH Konstanz studieren mindestens 500 Studenten&quot;;" correct="false"/><answer notice="" body="String text2 = &quot;An der FH Konstanz studieren mindestens 500 Studenten.&quot;;" correct="true"/><answer notice="" body="String text4 = &quot;An der HTWG Konstanz bestehen die Studenten zu 80% Ihre Prüfungen.&quot;;" correct="false"/><answer notice="" body="String text5 = &quot;An der HTWG Konstanz studieren ebenso 40 Studenten aus dem Ausland.&quot;;" correct="false"/></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="Nun, dieses Beispiel stammt von Studierenden. Ähnlichkeiten mit real existierenden Personen sind rein zufällig. Und in der Klausur wird das eher einfacher. Allerdings müssen Sie auch einen regulären Ausdruck zu einem gegebenen Problem entwickeln." num_allowed_wrong="0" name=" Wer matched? Nummer 2" body="&lt;p&gt;Gegeben sei folgender regulärer Ausdruck:&lt;/p&gt;&#13;&#10;&lt;pre&gt;(([a-zA-Z]*)\s)*(([0-9]+)|([0-9]+\.[0-9]+\.[0-9]+))(\s[a-zA-Z]*)*\.&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Welche Zeichenkette matched diesen Ausdruck?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="Fabian hat am 20.05.1987 Geburstag und ist somit das junge Huhn im Stall." correct="true"/><answer notice="" body="Steffen ist 3 Tage aelter also Fabian." correct="true"/><answer notice="" body="Beide studieren an der HTWG seit 2007." correct="true"/><answer notice="" body="zudem sind beide schon zurueck gestuft worden." correct="false"/></question><question type="MultipleChoice" notice_on_wrong="" pattern="" notice="Wie Sie nicht nur an der Orthografie merken, stammt auch dieser Vorschlag aus den Reihen der Studierenden. Bilden Sie sich Ihre eigene Meinung darüber, wie angesagt welcher Studiengang ist. :-)" num_allowed_wrong="0" name=" Wer matched? Nummer 3" body="&lt;p&gt;Gegeben sei wieder ein Pattern:&lt;/p&gt;&#13;&#10;&lt;pre&gt;([a-zA-Z]|[ä])*(\s([a-zA-Z]|[ä])*)*&lt;/pre&gt;&#13;&#10;&lt;p&gt;Welche Zeichenkette &quot;matched&quot; das Pattern?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="An der HTWG gibt es Fakultäten" correct="true"/><answer notice="" body="Die Elite Fakultät ist die Fakultät Informatik" correct="true"/><answer notice="" body="Nun Kommt das beste! SE und TI ist der Angesagteste Studiengang" correct="false"/><answer notice="" body="Nun Hab ich eine Frage. Welcher Ausdruck stimmt nicht?" correct="false"/></question></lesson><lesson description="" required_correct_answers="70" distance_to_next="1" name="Collections und Hashes" body="" sort="9" max_wrong_answers="3"><question type="SingleChoice" notice_on_wrong="" pattern="" notice="Zum einen sollte darauf geachtet werden, dass keine Werte größer 3 (0...3) erzeugt werden, zum anderen, dass die Hashfunktion sensibel auf das Vertauschen von Buchstaben reagiert, beispielsweise für hanna und und annah verschiedene Werte liefert." num_allowed_wrong="0" name="Hash Funktion von Strings" body="&lt;p&gt;Es gibt mehrere Möglichkeiten, Hash-Funktionen zu schreiben. Bitte wählen Sie die beste aus, um den Hash-Wert eines Strings zu bestimmen. die Lösungen im Text ergänzen folgendes Stück Programm-Code:&lt;/p&gt;&#13;&#10;&lt;pre&gt;public int hashCode(){&lt;br /&gt;  int hashi = 0;&lt;br /&gt;  &amp;lt;hier der zu ergänzende Code&amp;gt;&lt;br /&gt;  return hashi;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Bitte beachten Sie, dass die Werte in ein Array a = String[4] eingefühgt werden.&lt;/p&gt;&#13;&#10;&lt;p&gt;Variante 1:&lt;/p&gt;&#13;&#10;&lt;pre&gt;for (int i = 0; i &amp;lt; string.length; i++){&lt;br /&gt;  hashi += string.charAt(i);&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt;Variante 2:&lt;/p&gt;&#13;&#10;&lt;pre&gt;for (int i = 0; i &amp;lt; string.length; i++){&lt;br /&gt;  hashi += string.charAt(i) * i;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt; &lt;/p&gt;&#13;&#10;&lt;p&gt;Variante 3:&lt;/p&gt;&#13;&#10;&lt;pre&gt;for (int i = 0; i &amp;lt; string.length; i++){&lt;br /&gt;  hashi += string.charAt(i);&lt;br /&gt;}&lt;br /&gt;hashi = hashi % 4;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;p&gt;Variante 4:&lt;/p&gt;&#13;&#10;&lt;pre&gt;for (int i = 0; i &amp;lt; string.length; i++){&lt;br /&gt;  hashi += string.charAt(i) * i;&lt;br /&gt;}&lt;br /&gt;hashi = hashi % 4;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;&lt;br /&gt;&lt;/pre&gt;" notice_on_correct=""><answer notice="" body="Variante 1" correct="false"/><answer notice="" body="Variante 2" correct="false"/><answer notice="" body="Variante 3" correct="false"/><answer notice="" body="Variante 4" correct="true"/></question><question type="MatchTask" notice_on_wrong="" pattern="" notice="Es gibt auch für die Interfaces SortedMap und Queue mehrere implementierende Klassen. Die Zuordnung ist in dieser Aufgabe trotzdem eindeutig." num_allowed_wrong="0" name=" Java Collection Framework" body="&lt;p&gt;Bitte ordnen Sie die Begriffe zu:&lt;/p&gt;&#13;&#10;&lt;p&gt;&lt;img src=&quot;../../uploads/0000/0016/jcf.png&quot; alt=&quot;Java Collection Framework&quot; width=&quot;600&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;" notice_on_correct=""><answer notice="List" body="Nummer 1" correct="true"/><answer notice="HashSet" body="Nummer 2" correct="true"/><answer notice="SortedSet" body="Nummer 3" correct="true"/><answer notice="TreeSet" body="Nummer 4" correct="true"/><answer notice="Queue" body="Nummer 5" correct="true"/><answer notice="ArrayBlockingQueue" body="Nummer 6" correct="true"/><answer notice="Map" body="Nummer 7" correct="true"/><answer notice="HashMap" body="Nummer 8" correct="true"/></question><question type="MultipleChoice" notice_on_wrong="In der Tat können unterschiedliche Objekte zum gleichen HashCode führen. Die Funktion ist also nicht ein-eindeutig. Sie ist aber für ein gegebenes Objekt immer konstant." pattern="" notice="" num_allowed_wrong="0" name=" Hashfunktionen" body="&lt;p&gt;Welche Aussagen über Hashfunktionen sind korrekt?&lt;/p&gt;&#13;&#10;&lt;p&gt;Hashfunktionen...&lt;/p&gt;" notice_on_correct="Wunderbar!"><answer notice="" body="... liefern immer einen int-Wert zurück" correct="true"/><answer notice="" body="... müssen Objekte auf Ganzzahlen in einem vorgegebenen Wertebereich abbilden" correct="true"/><answer notice="" body="... sind für jedes Objekt eineindeutig" correct="false"/><answer notice="" body="... müssen für ein bestimmtes Objekt immer die gleiche Zahl sein" correct="true"/><answer notice="" body="... können für unterschiedliche Objekte zufällig gleich sein" correct="true"/><answer notice="" body="... sollten nur gemeinsam mit der equals()-Funktion überschrieben werden" correct="true"/></question><question type="SingleChoice" notice_on_wrong="" pattern="" notice="Die hashCode()-Funktion und equals()-Funktion müssen zueinander passen. Wenn ein Auto eindeutig durch die Fahrgestellnummer gekennzeichnet ist, so muss auch die Position im Array (d.h. der Hashcode) von dieser Fahrgestellnummer abhängig sein. Weitere Klassenvariablen könnten hinzugezogen werden. Doch dazu gibt es keinen Anlass und macht den Code nur komplizierter und die hashCode()-Funktion nicht besser." num_allowed_wrong="0" name=" Hash und Equals" body="&lt;p&gt;Gegeben sei eine Klasse Auto:&lt;/p&gt;&#13;&#10;&lt;pre&gt;public class Auto {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;  private in fahrgestellnummer;&lt;br /&gt;  private String typ;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;  private Color farbe;&lt;br /&gt;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;  //Konstruktor, getter, setter&lt;/pre&gt;&#13;&#10;&lt;pre&gt;  public boolean equals(Object o) {&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    if (null == o) {return false;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    if (this == o) {return true;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    if(! o instanceof Auto) {return false;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    Auto a = (Auto)o;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    if (fahrgestellnummer = a.getFahrgestellnummer() { return true;}&lt;/pre&gt;&#13;&#10;&lt;pre&gt;    return false;&lt;/pre&gt;&#13;&#10;&lt;pre&gt;  }&lt;br /&gt;}&lt;/pre&gt;&#13;&#10;&lt;p&gt;Welche Klassenvariablen müssen Sie bei der Implementierung der HashCode-Funktion auf jeden Fall berücksichtigen?&lt;/p&gt;" notice_on_correct=""><answer notice="" body="fahrgestellnummer" correct="true"/><answer notice="" body="fahrgestellnummer und farbe" correct="false"/><answer notice="" body="alle Klassenvariablen" correct="false"/><answer notice="" body="das hängt von der Geschäftslogik ab" correct="false"/><answer notice="" body="grundsätzlich keine Klassenvariablen" correct="false"/></question></lesson></course>